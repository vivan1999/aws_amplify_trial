{"ast":null,"code":"import { m as matchBreakpoint } from './breakpoints.js';\nimport { T as TypedEvent } from './typed-event.js';\nvar __classPrivateFieldGet$1 = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet$1 = undefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _ApplicationLayoutService_supportedBreakpoints, _ApplicationLayoutService_breakpointChangeListener, _ApplicationLayoutService_breakpoint, _ApplicationLayoutService_isDetectionEnabled;\nclass ApplicationLayoutService {\n  constructor() {\n    // Keep order of breakpoints\n    _ApplicationLayoutService_supportedBreakpoints.set(this, ['sm', 'md', 'lg']);\n    _ApplicationLayoutService_breakpointChangeListener.set(this, new TypedEvent());\n    _ApplicationLayoutService_breakpoint.set(this, 'lg');\n    _ApplicationLayoutService_isDetectionEnabled.set(this, true);\n    if (typeof window !== 'undefined') {\n      window.addEventListener('resize', this.onResize.bind(this));\n      this.onResize();\n    }\n  }\n  get breakpoint() {\n    return __classPrivateFieldGet$1(this, _ApplicationLayoutService_breakpoint, \"f\");\n  }\n  get onChange() {\n    return __classPrivateFieldGet$1(this, _ApplicationLayoutService_breakpointChangeListener, \"f\");\n  }\n  get isDetectionEnabled() {\n    return __classPrivateFieldGet$1(this, _ApplicationLayoutService_isDetectionEnabled, \"f\");\n  }\n  onResize() {\n    if (!__classPrivateFieldGet$1(this, _ApplicationLayoutService_isDetectionEnabled, \"f\")) {\n      return;\n    }\n    if (!__classPrivateFieldGet$1(this, _ApplicationLayoutService_supportedBreakpoints, \"f\")) {\n      return;\n    }\n    const matchBreakpoints = [];\n    const breakpoints = __classPrivateFieldGet$1(this, _ApplicationLayoutService_supportedBreakpoints, \"f\");\n    breakpoints.forEach(breakpoint => {\n      const match = matchBreakpoint(breakpoint);\n      matchBreakpoints.push([breakpoint, match]);\n    });\n    if (matchBreakpoints.every(([_, match]) => match === false)) {\n      let breakPointIndex = 0;\n      if (!__classPrivateFieldGet$1(this, _ApplicationLayoutService_supportedBreakpoints, \"f\").includes('lg')) {\n        breakPointIndex = matchBreakpoints.length - 1;\n      }\n      const [breakpoint, _] = matchBreakpoints[breakPointIndex];\n      __classPrivateFieldGet$1(this, _ApplicationLayoutService_breakpointChangeListener, \"f\").emit(breakpoint);\n      __classPrivateFieldSet$1(this, _ApplicationLayoutService_breakpoint, breakpoint, \"f\");\n      return;\n    }\n    for (const [breakpoint, match] of matchBreakpoints.reverse()) {\n      if (match) {\n        __classPrivateFieldGet$1(this, _ApplicationLayoutService_breakpointChangeListener, \"f\").emit(breakpoint);\n        __classPrivateFieldSet$1(this, _ApplicationLayoutService_breakpoint, breakpoint, \"f\");\n        break;\n      }\n    }\n  }\n  disableBreakpointDetection() {\n    __classPrivateFieldSet$1(this, _ApplicationLayoutService_isDetectionEnabled, false, \"f\");\n  }\n  enableBreakpointDetection() {\n    __classPrivateFieldSet$1(this, _ApplicationLayoutService_isDetectionEnabled, true, \"f\");\n  }\n  setBreakpoint(breakpoint) {\n    __classPrivateFieldSet$1(this, _ApplicationLayoutService_breakpoint, breakpoint, \"f\");\n    __classPrivateFieldGet$1(this, _ApplicationLayoutService_breakpointChangeListener, \"f\").emit(breakpoint);\n  }\n  setBreakpoints(breakpoints) {\n    __classPrivateFieldSet$1(this, _ApplicationLayoutService_supportedBreakpoints, breakpoints, \"f\");\n    this.onResize();\n  }\n}\n_ApplicationLayoutService_supportedBreakpoints = new WeakMap(), _ApplicationLayoutService_breakpointChangeListener = new WeakMap(), _ApplicationLayoutService_breakpoint = new WeakMap(), _ApplicationLayoutService_isDetectionEnabled = new WeakMap();\nconst applicationLayoutService = new ApplicationLayoutService();\n\n/*\n * SPDX-FileCopyrightText: 2023 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MenuService_isPinned;\nclass MenuService {\n  constructor() {\n    this.menuElement = null;\n    this.menuExpandChange = new TypedEvent();\n    _MenuService_isPinned.set(this, false);\n  }\n  register(menuElement) {\n    if (this.menuElement) {\n      console.warn('Menu already defined');\n      return;\n    }\n    this.menuElement = menuElement;\n    this.menuElement.addEventListener('expandChange', event => {\n      this.menuExpandChange.emit(event.detail);\n    });\n  }\n  setIsPinned(pinned) {\n    __classPrivateFieldSet(this, _MenuService_isPinned, pinned, \"f\");\n  }\n  async open() {\n    if (this.menuElement) {\n      this.menuElement.toggleMenu(true);\n      return true;\n    }\n    return false;\n  }\n  async close() {\n    if (this.menuElement) {\n      this.menuElement.toggleMenu(false);\n      return true;\n    }\n    return false;\n  }\n  async toggle() {\n    if (this.menuElement) {\n      this.menuElement.toggleMenu();\n      return true;\n    }\n    return false;\n  }\n  get nativeElement() {\n    return this.menuElement;\n  }\n  get expandChange() {\n    return this.menuExpandChange;\n  }\n  get isPinned() {\n    return __classPrivateFieldGet(this, _MenuService_isPinned, \"f\");\n  }\n}\n_MenuService_isPinned = new WeakMap();\nconst menuController = new MenuService();\nexport { applicationLayoutService as a, menuController as m };","map":{"version":3,"names":["ApplicationLayoutService","constructor","_ApplicationLayoutService_supportedBreakpoints","set","_ApplicationLayoutService_breakpointChangeListener","TypedEvent","_ApplicationLayoutService_breakpoint","_ApplicationLayoutService_isDetectionEnabled","window","addEventListener","onResize","bind","breakpoint","__classPrivateFieldGet$1","onChange","isDetectionEnabled","matchBreakpoints","breakpoints","forEach","match","matchBreakpoint","push","every","_","breakPointIndex","includes","length","emit","__classPrivateFieldSet$1","reverse","disableBreakpointDetection","enableBreakpointDetection","setBreakpoint","setBreakpoints","applicationLayoutService","MenuService","menuElement","menuExpandChange","_MenuService_isPinned","register","console","warn","event","detail","setIsPinned","pinned","__classPrivateFieldSet","open","toggleMenu","close","toggle","nativeElement","expandChange","isPinned","__classPrivateFieldGet","menuController"],"sources":["D:\\pci_project_new\\node_modules\\@siemens\\ix\\components\\src\\components\\utils\\application-layout\\service.ts","D:\\pci_project_new\\node_modules\\@siemens\\ix\\components\\src\\components\\utils\\menu-service\\menu-service.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2023 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Breakpoint, matchBreakpoint } from '../breakpoints';\nimport { TypedEvent } from '../typed-event';\n\nclass ApplicationLayoutService {\n  // Keep order of breakpoints\n  #supportedBreakpoints: Breakpoint[] = ['sm', 'md', 'lg'];\n  #breakpointChangeListener = new TypedEvent<Breakpoint>();\n  #breakpoint: Breakpoint = 'lg';\n\n  #isDetectionEnabled = true;\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('resize', this.onResize.bind(this));\n      this.onResize();\n    }\n  }\n\n  get breakpoint() {\n    return this.#breakpoint;\n  }\n\n  get onChange() {\n    return this.#breakpointChangeListener;\n  }\n\n  get isDetectionEnabled() {\n    return this.#isDetectionEnabled;\n  }\n\n  private onResize() {\n    if (!this.#isDetectionEnabled) {\n      return;\n    }\n    if (!this.#supportedBreakpoints) {\n      return;\n    }\n    const matchBreakpoints: [Breakpoint, boolean][] = [];\n\n    const breakpoints = this.#supportedBreakpoints;\n\n    breakpoints.forEach((breakpoint) => {\n      const match = matchBreakpoint(breakpoint);\n      matchBreakpoints.push([breakpoint, match]);\n    });\n\n    if (matchBreakpoints.every(([_, match]) => match === false)) {\n      let breakPointIndex = 0;\n      if (!this.#supportedBreakpoints.includes('lg')) {\n        breakPointIndex = matchBreakpoints.length - 1;\n      }\n\n      const [breakpoint, _] = matchBreakpoints[breakPointIndex];\n      this.#breakpointChangeListener.emit(breakpoint);\n      this.#breakpoint = breakpoint;\n      return;\n    }\n\n    for (const [breakpoint, match] of matchBreakpoints.reverse()) {\n      if (match) {\n        this.#breakpointChangeListener.emit(breakpoint);\n        this.#breakpoint = breakpoint;\n        break;\n      }\n    }\n  }\n\n  public disableBreakpointDetection() {\n    this.#isDetectionEnabled = false;\n  }\n\n  public enableBreakpointDetection() {\n    this.#isDetectionEnabled = true;\n  }\n\n  public setBreakpoint(breakpoint: Breakpoint) {\n    this.#breakpoint = breakpoint;\n    this.#breakpointChangeListener.emit(breakpoint);\n  }\n\n  public setBreakpoints(breakpoints: Breakpoint[]) {\n    this.#supportedBreakpoints = breakpoints;\n    this.onResize();\n  }\n}\n\nexport const applicationLayoutService = new ApplicationLayoutService();\n","/*\n * SPDX-FileCopyrightText: 2023 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { TypedEvent } from '../typed-event';\n\nclass MenuService {\n  menuElement: HTMLIxMenuElement | null = null;\n  menuExpandChange = new TypedEvent<boolean>();\n  #isPinned = false;\n\n  register(menuElement: HTMLIxMenuElement) {\n    if (this.menuElement) {\n      console.warn('Menu already defined');\n      return;\n    }\n    this.menuElement = menuElement;\n    this.menuElement.addEventListener(\n      'expandChange',\n      (event: CustomEvent<boolean>) => {\n        this.menuExpandChange.emit(event.detail);\n      }\n    );\n  }\n\n  public setIsPinned(pinned: boolean) {\n    this.#isPinned = pinned;\n  }\n\n  public async open() {\n    if (this.menuElement) {\n      this.menuElement.toggleMenu(true);\n      return true;\n    }\n\n    return false;\n  }\n\n  public async close() {\n    if (this.menuElement) {\n      this.menuElement.toggleMenu(false);\n      return true;\n    }\n\n    return false;\n  }\n\n  public async toggle() {\n    if (this.menuElement) {\n      this.menuElement.toggleMenu();\n      return true;\n    }\n\n    return false;\n  }\n\n  get nativeElement() {\n    return this.menuElement;\n  }\n\n  get expandChange() {\n    return this.menuExpandChange;\n  }\n\n  get isPinned() {\n    return this.#isPinned;\n  }\n}\n\nexport const menuController = new MenuService();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}