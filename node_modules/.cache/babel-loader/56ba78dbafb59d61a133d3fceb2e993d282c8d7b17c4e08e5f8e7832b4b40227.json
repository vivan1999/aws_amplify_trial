{"ast":null,"code":"/*\n * SPDX-FileCopyrightText: 2023 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nclass TypedEvent {\n  constructor() {\n    this.listeners = [];\n    this.listenersOncer = [];\n    this.on = listener => {\n      this.listeners.push(listener);\n      return {\n        dispose: () => this.off(listener)\n      };\n    };\n    this.once = listener => {\n      this.listenersOncer.push(listener);\n    };\n    this.off = listener => {\n      const callbackIndex = this.listeners.indexOf(listener);\n      if (callbackIndex > -1) {\n        this.listeners.splice(callbackIndex, 1);\n      }\n    };\n    this.emit = event => {\n      /** Update any general listeners */\n      this.listeners.forEach(listener => listener(event));\n      /** Clear the `once` queue */\n      if (this.listenersOncer.length > 0) {\n        const toCall = this.listenersOncer;\n        this.listenersOncer = [];\n        toCall.forEach(listener => listener(event));\n      }\n    };\n    this.pipe = te => {\n      return this.on(e => te.emit(e));\n    };\n  }\n}\nexport { TypedEvent as T };","map":{"version":3,"names":["TypedEvent","constructor","listeners","listenersOncer","on","listener","push","dispose","off","once","callbackIndex","indexOf","splice","emit","event","forEach","length","toCall","pipe","te","e"],"sources":["D:\\pci_project_new\\node_modules\\@siemens\\ix\\dist\\esm\\src\\components\\utils\\typed-event.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2023 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport interface Listener<T> {\n  (event: T): any;\n}\n\nexport interface Disposable {\n  dispose(): void;\n}\n\nexport class TypedEvent<T> {\n  public readonly listeners: Listener<T>[] = [];\n  public listenersOncer: Listener<T>[] = [];\n\n  on = (listener: Listener<T>): Disposable => {\n    this.listeners.push(listener);\n    return {\n      dispose: () => this.off(listener),\n    };\n  };\n\n  once = (listener: Listener<T>): void => {\n    this.listenersOncer.push(listener);\n  };\n\n  off = (listener: Listener<T>) => {\n    const callbackIndex = this.listeners.indexOf(listener);\n    if (callbackIndex > -1) {\n      this.listeners.splice(callbackIndex, 1);\n    }\n  };\n\n  emit = (event: T) => {\n    /** Update any general listeners */\n    this.listeners.forEach((listener) => listener(event));\n\n    /** Clear the `once` queue */\n    if (this.listenersOncer.length > 0) {\n      const toCall = this.listenersOncer;\n      this.listenersOncer = [];\n      toCall.forEach((listener) => listener(event));\n    }\n  };\n\n  pipe = (te: TypedEvent<T>): Disposable => {\n    return this.on((e) => te.emit(e));\n  };\n}\n"],"mappings":"AAAA;;;;;;;;MAiBaA,UAAU;EAAvBC,YAAA;IACkB,KAAAC,SAAS,GAAkB,EAAE;IACtC,KAAAC,cAAc,GAAkB,EAAE;IAEzC,KAAAC,EAAE,GAAIC,QAAqB;MACzB,IAAI,CAACH,SAAS,CAACI,IAAI,CAACD,QAAQ,CAAC;MAC7B,OAAO;QACLE,OAAO,EAAEA,CAAA,KAAM,IAAI,CAACC,GAAG,CAACH,QAAQ;OACjC;KACF;IAED,KAAAI,IAAI,GAAIJ,QAAqB;MAC3B,IAAI,CAACF,cAAc,CAACG,IAAI,CAACD,QAAQ,CAAC;KACnC;IAED,KAAAG,GAAG,GAAIH,QAAqB;MAC1B,MAAMK,aAAa,GAAG,IAAI,CAACR,SAAS,CAACS,OAAO,CAACN,QAAQ,CAAC;MACtD,IAAIK,aAAa,GAAG,CAAC,CAAC,EAAE;QACtB,IAAI,CAACR,SAAS,CAACU,MAAM,CAACF,aAAa,EAAE,CAAC,CAAC;;KAE1C;IAED,KAAAG,IAAI,GAAIC,KAAQ;;MAEd,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAEV,QAAQ,IAAKA,QAAQ,CAACS,KAAK,CAAC,CAAC;;MAGrD,IAAI,IAAI,CAACX,cAAc,CAACa,MAAM,GAAG,CAAC,EAAE;QAClC,MAAMC,MAAM,GAAG,IAAI,CAACd,cAAc;QAClC,IAAI,CAACA,cAAc,GAAG,EAAE;QACxBc,MAAM,CAACF,OAAO,CAAEV,QAAQ,IAAKA,QAAQ,CAACS,KAAK,CAAC,CAAC;;KAEhD;IAED,KAAAI,IAAI,GAAIC,EAAiB;MACvB,OAAO,IAAI,CAACf,EAAE,CAAEgB,CAAC,IAAKD,EAAE,CAACN,IAAI,CAACO,CAAC,CAAC,CAAC;KAClC"},"metadata":{},"sourceType":"module","externalDependencies":[]}